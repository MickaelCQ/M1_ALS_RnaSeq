---
title: "Analyse comparative des méthodes de normalisation RNA-Seq ciblé - SLA"
author: "Mickael Coquerelle"
date: "`r format(Sys.Date(), '%d %B %Y')`"
output:
  pdf_document:
  toc: true
number_sections: true
highlight: tango
fig_caption: true
latex_engine: pdflatex
fontsize: 11pt
mainfont: "Helvetica"
geometry: "left=1.5cm,right=1.5cm,top=2cm,bottom=2cm"
---
  
```{r setup, include=FALSE}
# ────────────────────────────────────────────────────────────────────────────────
#  Chunk technique global : options knitr
# ────────────────────────────────────────────────────────────────────────────────
knitr::opts_chunk$set(
  echo        = TRUE,   # Montrer le code 
  warning     = FALSE,  # Ne pas surcharger le PDF
  message     = FALSE,  # Masquer mes messages de chargement
  fig.width   = 8.5,    # Taille par défaut des figures
  fig.height  = 5,
  dpi         = 600
)
```
# Avant-propos et objectifs

Ce rapport sert de synthèse a mes différentes investigations et scripts/essais que j'ai pu effectuer en \texttt{R}, pour générer/évaluer mes données de comptages et surtout à mes investigations sur les méthodes de normalisation pour faire de l'analyse quantitative dans le périmètre du RNA-Seq ciblé sur le panel de 56 gènes et tout ce que cela implique en terme de contraintes et de limites, comme détaillé dans mes anciennes réalisations. 

Ici je traite de **TPM** (intègre la longueur des genes), **TMM** (concu au départ pour le transcriptome complet) et **RLE** (hypothèse d'une médiane stable). Je tiens à rappeler également que les approches classiques dans notre contexte de faible nombre de gènes sont relativements fragiles (cf. mon travail bibliographique sur les méthodes de normalisation).

# Préparation/mise en forme du dataset

```{r lib, include=TRUE}
# ────────────────────────────────────────────────────────────────────────────────
#  Charger les librairies nécessaires.
#  edgeR : pour calcNormFactors (TMM, RLE) + cpm()
#  purrr : fusion propre des dataframes
# ────────────────────────────────────────────────────────────────────────────────
library(readr)      # Import TSV
library(dplyr)      # Manipulations de données
library(tidyr)      # pivot_longer / separate
library(ggplot2)    # Visualisations
library(edgeR)      # Normalisation TMM & RLE
library(tibble)     # rownames_to_column
library(purrr)      # reduce pour fusion
library(broom)      # tidy() sur modèles statistiques
library(kableExtra) # Jolis tableaux LaTeX
```

# Import/préparation de la matrice de comptages

```{r dataset}
#  Lecture du fichier de comptages généré par featureCounts (-f).
#  Colonne : Geneid | nom_gène | Chr | Longueur | échantillons...

tableau_comptages_bruts <- read_tsv("~/Final_counts_56genes.tsv", show_col_types = FALSE)

# Passage au format long pour faciliter les transformations ultérieures.
comptages_long <- tableau_comptages_bruts %>%
  pivot_longer(
    cols      = -c(Geneid, nom_gene = gene_name, Chr, Longueur = Length),
    names_to  = "ID_complet",
    values_to = "lectures_brutes"
  ) %>%
  separate(
    identifiant_complet,
    into    = c("run", "echantillon", "condition"),
    sep     = "-",
    remove  = TRUE
  )
```

# Normalisations

```{r matricecomptes}
  # On créer une matrice ge pour edgeR
comptages_larges <- comptages_long |> group_by(nom_gene, echantillon) |> summarise(total_lectures = sum(lectures_brutes), .groups= "drop") |> pivot_wider(names_from = echantillon, values_from = total_lectures) |> column_to_rownames("nom_gene")
```

## TPM
```{r tpm}
tpm_long <- comptages_long |> group_by(echantillon) |> mutate(
  taux_expression = lectures_brutes / Longueur,
  TPM_transcrits_par_M = taux_expression / sum(taux_expression) * 1e6) |> ungroup ()
```


## TMM (Trimmed Mean of M-values)
```{r TMM}

objet_tmm_edge <- DGEList(counts = as.matrix(comptages_larges))
objet_tmm_edge <- calcNormFactors(objet_tmm_edge, method ="TMM")

matrice_cpm_tmm <- cpm(objet_tmm_edge, normalized.lib.sizes = TRUE)
```

## RLE (Relative Log expression)
```{r RLE}
objet_rle_edge <- DGEList(counts = as.matrix(comptages_larges))
objet_rle_edge <- calcNormFactors(objet_rle_edge, method ="RLE")

matrice_cpm_rle <- cpm(objet_rle_edge, normalized.lib.size = TRUE)
```

## Création d'un tibble global des comptes normalisés 
```{r tibble}
tpm_tb <- tpm_long |> select(echantillon, nom_gene, TPM_transcrits_par_M)

tmm_tb <- matrice_cpm_tmm |> as.data.frame() |> rownames_to_column("nom_gene") |> pivot_longer(-nom_gene, names_to = "echantillon", values_to ="TMM_cpm")

rle_tb <- matrice_cpm_rle |> as.data.frame() |> rownames_to_column("nom_gene") |> pivot_longer(-nom_gene,
names_to = "echantillon", values_to = "RLE_cpm")

donnees_normalisees <- reduce(list(tpm_tb, tmm_tb, rle_tb), full_join, by = c("echantillon","nom_gene")) |> 
  left_join (comptages_long |> distinct(echantillon,run,condition), by ="echantillon")
```

## Visualisation des comptes normalisés
On regarde a premiere vue comment les comptes normalisés ce répartissent par gènes, avec une facet par gène pour les trois approches. L'idée étant surtout ici d'observer si il y'a des différences excessives entre les approches et comprendre dérrière à quoi elles peuvent êtres dues ... 

```{r graph gene}
liste_genes <- unique(donnees_normalisees$nom_gene)
groupes_genes <- split(liste_genes, ceiling(seq_along(liste_genes) /7 ))

for (groupe in seq_along(groupes_genes)) {
  sous_groupe <- donnees_normalisees |>  filter(nom_gene %in% groupes_genes[[groupe]])
  p <- ggplot(sous_groupe, aes(x= echantillon))+
    geom_line(aes(y =TPM_transcrits_par_M, color = "TPM", group =1),linewidth = 0.7)+
    
}
```
